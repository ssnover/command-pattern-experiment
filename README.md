# Command Pattern Experiment
I've taken two stabs at implementing the command pattern here.

The first one makes use of enums to implement Command objects which receivers can process. A command server queues up commands and as it pops each command off it iterates through the vector of receivers and let's each one handle it. This is flexible in that multiple receivers can receive a command, but they do not own the data and this could be rather slow performance-wise.

The second one iterates on the first implementation by introducing a registry. The Command enum from the first iteration is split into a CommandId and CommandArgs which are joined under a single Command struct for the command server. A HashMap registers pairs of CommandIds with pointers to Receivers who can handle that specific command. This should be more performant, if a Command is unhandled you can throw an error over it, and the receiver can take ownership of the data. However you lose the ability to react to a Command with multiple receivers, which will now require duplicating commands or having a more complex model including Observers. To make this a little less trivial I also made the Command Receiver's `handle_command` take the receiver as mutable. This required collecting all of the receivers into `Arc<Mutex<Receiver>>` wrappers to satisfy Rust's borrow checker and to ensure there are no data races in accessing the receivers.